The Minoperation class is used to find minCost path from origin string to target string 
by addition, deletion, subsitituion, and take anagram, these four operations.

Requirement: 
    verison: java8, since some part of method using lambda expression.
    Files: all text(dictionary/instructions) file should 
    be in the same directory as the .class file
    
format:
    instrution file should contain 3 lines as in the example below 
    1 3 5 3 
    tes
    fun 
    the integer in the first line corresponding to the cost for add, delete, subsitution and anagram
    second line is the origin string and last line is the target string

Complie & run: 
    in the root directory on terminal type  javac MinOperations.java 
    after compiling, run the program while following command line pop out,
    "Enter fileName or type exit for stop: " 
    simply type the filename contains instruction, for instance, "test.txt" to run
    or "exit" to quit the program


Idea: 
    using A* search algorithm to find the shortest path, and use
    Levenshtein distance as the heuristic funtion. A* is known for smaller 
    searching space when comparing with dijkstra algorithm(which also disregard the importance of
    Levenshtein distance) and therefore, A* has better performance when size of dictionaryList is large.

diffulties: To be honest, it's a really interesting and a bit challenging puzzles, 
    1. generate all anagram for each string state
        solutoin: generate the anagram HashMap using the string formed by its sorted characters as the key
        and List<String> contains all the string with same characters as value
    2. slow performance and undirected space searching if only use dijkstra algorithm
        solution: A* implmented by priorityqueue as fronter to store all potential children generated 
        by four operations sorted by (cost + estimationFunction)

Enhancement:
    if the search space is really large, which might put many unlikely canditates into the fronter
    and thus, slow the performance
        suggestion: use 2nd fronter, for all string with (cost + estimationFunction) < threshold,
        put them into the 1st fronter, leave the rest into the 2nd, and only expanding the 1st fronter when searching,
        at the end, compare the optimal cost generated by frontier 1 with threshold,  smaller than threshold, return 
        else: add all value from frontier 2 into frontier 1, reexpand again. Idealy, this could drastically reduce the 
        search space when we have a really large wordList;

potential issues: 
    since the major part if this program is for the algorithm, I didn't spend much time in polishing the user interaction
    1. Hashcollision might happen, for large dictionaryList size
    2. some uncatched exception, for some rare conner case.
    


Reference:

1. wordList http://www-01.sil.org/linguistics/wordlists/english/wordlist/wordsEn.txt
2. A*   https://en.wikipedia.org/wiki/A*_search_algorithm
3. Levenshtein distance https://en.wikipedia.org/wiki/Levenshtein_distance
